<?php
//composer autoloader
require_once dirname(dirname(__DIR__)) . '/vendors/autoload.php';

use GuzzleHttp\Client;

/**
 * The gitHubDocs service class.
 *
 * @package gitHubDocs
 */
class GitHubDocs
{
    /** @var modX $modx */
    public $modx;
    /** @var Parsedown $parse */
    protected $parse;

    public $config = array();

    function __construct(modX &$modx, array $config = array())
    {
        $this->modx =& $modx;
        $basePath = $this->modx->getOption('githubdocs.core_path', $config, $this->modx->getOption('core_path') . 'components/githubdocs/');
        $assetsUrl = $this->modx->getOption('githubdocs.assets_url', $config, $this->modx->getOption('assets_url') . 'components/githubdocs/');
        $this->modx->lexicon->load('githubdocs:default');
        $this->config = array_merge(array(
            'basePath' => $basePath,
            'corePath' => $basePath,
            'vendorPath' => $basePath . 'vendors/',
            'modelPath' => $basePath . 'model/',
            'processorsPath' => $basePath . 'processors/',
            'templatesPath' => $basePath . 'templates/',
            'chunksPath' => $basePath . 'elements/chunks/',
            'jsUrl' => $assetsUrl . 'mgr/js/',
            'cssUrl' => $assetsUrl . 'mgr/css/',
            'assetsUrl' => $assetsUrl,
            'connectorUrl' => $assetsUrl . 'connector.php'
        ), $config);
        $this->modx->addPackage('githubdocs', $this->config['modelPath']);
        //dependencies
        $this->parse = new Parsedown();
    }

    /**
     * Returns GitHub API response.
     *
     * @param string $base_uri - Repository's content api url [https://developer.github.com/v3/repos/contents/]
     * @param string $uri - Relative path to target folder
     * @param bool $private - Private repo flag
     * @param bool $parse - Return parsed markdown flag
     *
     * @return array
     * @throws \GuzzleHttp\Exception\GuzzleException
     */
    public function get(string $base_uri, string $uri, bool $private = false, bool $parse = true)
    {
        $auth = array();
        if ($private) {
            $auth = array(
                'auth' => [$this->modx->getOption('githubdocs.act_username'), $this->modx->getOption('githubdocs.act_password')]
            );
        }
        try {
            $client = new GuzzleHttp\Client(['base_uri' => $base_uri]);
            $response = $client->request('GET', $uri, $auth);
            $body = json_decode($response->getBody(), true);
            if (isset($body['content']) && $parse) {
                $body['content'] = $this->parseMarkDown($body['content']);
            }
            return $body;
        } catch (GuzzleHttp\Exception\GuzzleException | Exception $e) {
            throw $e;
        }
    }

    /**
     * Returns html from base64 encoded markdown.
     *
     * @param string $md - Base64 encoded string
     *
     * @return mixed
     * @throws Exception
     */
    public function parseMarkDown(string $md = null)
    {
        try {
            $html = $this->parse->text(base64_decode($md));
            return $html;
        } catch (Exception $e) {
            throw $e;
        }
    }

    /**
     * Recursively walk a GitHub directory returning a multidimensional array of its folders and files.
     *
     * @param string $base_uri - Repository's content api url [https://developer.github.com/v3/repos/contents/]
     * @param string $uri - Relative path to target folder
     * @param bool $private - Private repo flag
     *
     * @return array
     * @throws \GuzzleHttp\Exception\GuzzleException
     */
    public function getDirTree(string $base_uri, string $uri, bool $private = false)
    {
        $output = array();
        $array = $this->get($base_uri, $uri, $private, false);
        foreach ($array as $k => $v) {
            if ($v['type'] == 'dir') {
                $v['children'] = $this->getDirTree($base_uri, $v['path'], $private);
            }
            $output[] = $v;
        }
        return $output;
    }

    /**
     * Recursively template a multidimensional array generated from getDirTree().
     *
     * @param array $array - An array generated by getDirTree()
     * @param string $base_url - Used for link building
     * @param string $dir_tpl - Chunk to use as a template
     * @param string $file_tpl - Chunk to use as a template
     * @param bool $debug - Debugging flag
     *
     * @return array
     * @throws Exception
     */
    public function styleDirTree(array $array, string $base_url, string $dir_tpl = '', string $file_tpl = '', bool $debug = false)
    {
        $output = array();
        foreach ($array as $k => $v) {
            //global
            $v['title'] = $this->cleanTitle($v['name']);
            $v['_links']['modx'] = $base_url . $this->cleanUrl($v['path']);
            //type specific
            switch ($v['type']) {
                case 'dir':
                    $v['children'] = $this->styleDirTree($v['children'], $base_url, $dir_tpl, $file_tpl, $debug);
                    if ($dir_tpl && !$debug) {
                        $v['children'] = implode("\n", $v['children']);
                        $v = $this->modx->getChunk($dir_tpl, $v);
                    }
                    break;
                case 'file':
                    if ($file_tpl && !$debug) {
                        $v = $this->modx->getChunk($file_tpl, $v);
                    }
                    break;
            }
            $output[] = $v;
        }
        return $output;
    }

    /**
     * Returns url or path with corrected extension for use with CustomRequest.
     *
     * @param string $url - url or path to clean
     *
     * @return string
     * @throws Exception
     */
    public function cleanUrl(string $url)
    {
        try {
            return str_replace(array('.md'), array('.html'), $url);
        } catch (Exception $e) {
            throw $e;
        }
    }

    /**
     * Returns a clean title.
     *
     * @param string $title - url or path to clean
     *
     * @return string
     * @throws Exception
     */
    public function cleanTitle(string $title)
    {
        try {
            return preg_replace(array(
                '/^(\d+|[a-zA-Z])_/',
                '/_/',
                '/(.md)$/'
            ), array(
                '',
                ' ',
                ''
            ), $title);
        } catch (Exception $e) {
            throw $e;
        }
    }

    /**
     * Custom exception handler
     *
     * @param Throwable $e
     * @param string $line (optional)
     * @param bool $fatal (optional)
     *
     * @return void;
     */
    public function exceptionHandler(Throwable $e, string $line = '', bool $fatal = false)
    {
        $code = $e->getCode();
        if ($code <= 6 || $fatal) {
            $level = modX::LOG_LEVEL_ERROR;
        } else {
            $level = modX::LOG_LEVEL_INFO;
        }
        $line = $line ? ' on Line ' . $line : '';
        $this->modx->log($level, '[gitHubDocs] - ' . $e->getMessage() . $line, '', '', '', $line);
        if ($fatal) {

        }
    }
}
